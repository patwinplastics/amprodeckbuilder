<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>American Pro PVC Deck Designer</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/babel.min.js"></script>
  <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
  <script src="https://cdn.babylonjs.com/postProcesses/babylonjs.postProcess.min.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Mulish:wght@500;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --mxt-corner-roundness: 6px;
      --toggle-blue: rgb(79, 193, 223);
      --font-color: #666666;
      --toolbar-bg: #f7f7f7;
      --dark-drop-shadow: 0 1px 1px 0 rgba(0, 0, 0, 0.2), 0 0 2px 1px rgba(0, 0, 0, 0.05);
      --mxt-font-header: 800 22px 'Mulish';
      --mxt-font-subheader: 700 15px 'Mulish';
      --mxt-font-body: 500 13px 'Mulish';
      --mxt-font-body-bold: 700 13px 'Mulish';
    }
    .bg-body { background-color: var(--toolbar-bg); }
    .font-family-mulish { font-family: 'Mulish', sans-serif; }
    h1 { font: var(--mxt-font-header); }
    h2 { font: var(--mxt-font-subheader); }
    button { font: var(--mxt-font-body-bold); }
    .tooltip { position: relative; display: inline-block; }
    .tooltip .tooltiptext {
      visibility: hidden; width: 200px; background-color: #555; color: #fff;
      text-align: center; border-radius: var(--mxt-corner-roundness); padding: 5px;
      position: absolute; z-index: 1000; bottom: 125%; left: 50%; margin-left: -100px;
      opacity: 0; transition: opacity 0.3s;
    }
    .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
    .panel {
      background-color: #fff; border-radius: var(--mxt-corner-roundness);
      padding: 1rem; margin-bottom: 1rem; box-shadow: var(--dark-drop-shadow);
    }
    .panel-header {
      cursor: pointer; font: var(--mxt-font-body-bold); display: flex;
      justify-content: space-between; align-items: center;
    }
    .mxt-form-control {
      width: 100%; height: 40px; border: 1px solid #ccc;
      border-radius: var(--mxt-corner-roundness); padding: 6px 12px;
      font: var(--mxt-font-body); color: var(--font-color);
      box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
    }
    .mxt-fraction-select {
      width: 80px; height: 40px; margin-left: 10px;
    }
    .mxt-btn {
      background: var(--toggle-blue); color: #fff; border-radius: var(--mxt-corner-roundness);
      padding: 8px 16px; font: var(--mxt-font-body-bold); cursor: pointer;
      box-shadow: var(--dark-drop-shadow); border: none;
    }
    .mxt-btn:hover { background: rgb(60, 174, 204); }
    .mxt-popover {
      position: absolute; background: #fff; border-radius: var(--mxt-corner-roundness);
      box-shadow: var(--dark-drop-shadow); padding: 10px; z-index: 1001;
      max-width: 300px; font: var(--mxt-font-body); color: var(--font-color);
    }
    .mxt-popover-content { text-align: center; }
  </style>
</head>
<body class="bg-body font-family-mulish">
  <div id="root"></div>
  <script type="text/babel">
    console.log('Starting Deck Designer');

    // Utility Functions
    function calculateDeckArea(points) {
      if (points.length < 3) return 0;
      return Math.abs(points.reduce((sum, p, i) => {
        const next = points[(i + 1) % points.length];
        return sum + (p.x * next.y - next.x * p.y);
      }, 0) / 2 / 50 / 50);
    }

    function createDefaultDeck(widthFt = 12, lengthFt = 12) {
      console.log('Creating default deck:', widthFt, 'x', lengthFt);
      const scale = 50 / 3.28084;
      const widthPx = widthFt * 3.28084 * scale;
      const lengthPx = lengthFt * 3.28084 * scale;
      return [
        { x: 0, y: 0 },
        { x: widthPx, y: 0 },
        { x: widthPx, y: lengthPx },
        { x: 0, y: lengthPx },
      ];
    }

    function parseFractionalFeet(value) {
      try {
        if (!value) return 0;
        const parts = value.trim().split(' ');
        let feet = parseInt(parts[0]) || 0;
        if (parts.length > 1) {
          const [num, denom] = parts[1].split('/').map(Number);
          if (num && denom && !isNaN(num) && !isNaN(denom)) feet += num / denom;
        }
        return feet;
      } catch (e) {
        console.error('Parse fractional feet error:', e);
        return 0;
      }
    }

    function calculateBOM(points, joistSpacing, beamSpacing, postSpacing, hasRailings) {
      try {
        const deckArea = calculateDeckArea(points);
        const boardWidth = 0.1397;
        const boardLengths = [3.6576, 4.8768, 6.096];
        const boardsNeeded = [];
        let remainingArea = deckArea;
        for (const length of boardLengths.sort((a, b) => b - a)) {
          const boards = Math.ceil(remainingArea / (length * boardWidth));
          if (boards > 0) {
            boardsNeeded.push({ length, count: boards });
            remainingArea -= boards * length * boardWidth;
          }
        }
        const bounds = points.length > 0 ? {
          minX: Math.min(...points.map(p => p.x / 50)),
          maxX: Math.max(...points.map(p => p.x / 50)),
          minZ: Math.min(...points.map(p => p.y / 50)),
          maxZ: Math.max(...points.map(p => p.y / 50)),
        } : { minX: 0, maxX: 0, minZ: 0, maxZ: 0 };
        const joistCount = Math.floor((bounds.maxX - bounds.minX) / joistSpacing) + 1;
        const joistLength = bounds.maxZ - bounds.minZ;
        const beamCount = Math.floor((bounds.maxZ - bounds.minZ) / beamSpacing) + 1;
        const beamLength = bounds.maxX - bounds.minX;
        const postCount = Math.floor((bounds.maxX - bounds.minX) / postSpacing + 1) * Math.floor((bounds.maxZ - bounds.minZ) / postSpacing + 1);
        const railingLength = hasRailings ? points.reduce((sum, p, i) => {
          const next = points[(i + 1) % points.length];
          return sum + Math.sqrt((next.x - p.x) ** 2 + (next.y - p.y) ** 2) / 50;
        }, 0) : 0;
        const fastenersPerBoard = 2;
        const totalFasteners = boardsNeeded.reduce((sum, b) => sum + b.count * fastenersPerBoard, 0);
        return { boardsNeeded, joistCount, joistLength, beamCount, beamLength, postCount, railingLength, totalFasteners };
      } catch (e) {
        console.error('BOM calculation error:', e);
        return { boardsNeeded: [], joistCount: 0, joistLength: 0, beamCount: 0, beamLength: 0, postCount: 0, railingLength: 0, totalFasteners: 0 };
      }
    }

    function exportBlueprint(canvas, points) {
      try {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.beginPath();
        points.forEach((p, i) => {
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.closePath();
        ctx.stroke();
        points.forEach((p, i) => {
          const next = points[(i + 1) % points.length];
          const length = Math.sqrt((next.x - p.x) ** 2 + (next.y - p.y) ** 2) / 50 * 3.28084;
          ctx.fillStyle = 'black';
          ctx.font = '12px bold Mulish';
          ctx.fillText(`${length.toFixed(2)} ft`, (p.x + next.x) / 2, (p.y + next.y) / 2);
        });
        const link = document.createElement('a');
        link.download = 'deck_blueprint.png';
        link.href = canvas.toDataURL();
        link.click();
      } catch (e) {
        console.error('Export blueprint error:', e);
      }
    }

    function exportSvg(points, width, height) {
      try {
        let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;
        svg += '<rect width="100%" height="100%" fill="white"/>';
        if (points.length > 2) {
          svg += '<polygon points="' + points.map(p => `${p.x},${p.y}`).join(' ') + '" fill="none" stroke="black" stroke-width="2"/>';
          points.forEach((p, i) => {
            const next = points[(i + 1) % points.length];
            const length = Math.sqrt((next.x - p.x) ** 2 + (next.y - p.y) ** 2) / 50 * 3.28084;
            const midX = (p.x + next.x) / 2;
            const midY = (p.y + next.y) / 2;
            svg += `<text x="${midX}" y="${midY}" font-family="Arial" font-size="12" font-weight="bold">${length.toFixed(2)} ft</text>`;
          });
        }
        svg += '</svg>';
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.download = 'deck_blueprint.svg';
        link.href = URL.createObjectURL(blob);
        link.click();
      } catch (e) {
        console.error('Export SVG error:', e);
      }
    }

    function exportBOM(bom, deckColor, deckTexture) {
      try {
        let csv = 'Item,Quantity,Unit,Details\n';
        bom.boardsNeeded.forEach(b => {
          csv += `Deck Board,${b.count},Each,American Pro PVC 1" x 5.5" x ${(b.length * 3.28084).toFixed(0)} ft (${deckColor}, ${deckTexture})\n`;
        });
        csv += `Joists,${bom.joistCount},Each,2x8 x ${bom.joistLength.toFixed(1)} m\n`;
        csv += `Beams,${bom.beamCount},Each,4x8 x ${bom.beamLength.toFixed(1)} m\n`;
        csv += `Posts,${bom.postCount},Each,4x4 x 2.4384 m\n`;
        if (bom.railingLength) csv += `Railing,${bom.railingLength.toFixed(1)},Meters,Standard Railing\n`;
        csv += `Fasteners,${bom.totalFasteners},Each,Hidden Fasteners\n`;
        const blob = new Blob([csv], { type: 'text/csv' });
        const link = document.createElement('a');
        link.download = 'deck_bom.csv';
        link.href = URL.createObjectURL(blob);
        link.click();
      } catch (e) {
        console.error('Export BOM error:', e);
      }
    }

    function exportJSON(points, deckColor, deckTexture, joistSpacing, beamSpacing, postSpacing, hasRailings, widthFt, lengthFt, stairSteps) {
      try {
        const project = {
          points, deckColor, deckTexture, joistSpacing, beamSpacing, postSpacing, hasRailings, widthFt, lengthFt, stairSteps, version: '1.1'
        };
        const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
        const link = document.createElement('a');
        link.download = 'deck_project.json';
        link.href = URL.createObjectURL(blob);
        link.click();
      } catch (e) {
        console.error('Export JSON error:', e);
      }
    }

    // React Components
    const { useState, useEffect, useRef } = React;
    const { createRoot } = ReactDOM;

    function Panel({ title, children }) {
      const [isOpen, setIsOpen] = useState(true);
      return (
        <div className="panel">
          <div className="panel-header" onClick={() => setIsOpen(!isOpen)}>
            <span>{title}</span>
            <span>{isOpen ? '▼' : '▶'}</span>
          </div>
          {isOpen && <div className="mt-2">{children}</div>}
        </div>
      );
    }

    function Popover({ isOpen, onClose, children, x, y }) {
      if (!isOpen) return null;
      return (
        <div className="mxt-popover" style={{ top: y, left: x }}>
          <div className="mxt-popover-content">
            <button className="mxt-btn" onClick={onClose}>Close</button>
            {children}
          </div>
        </div>
      );
    }

    function DeckDesigner() {
      console.log('Rendering DeckDesigner');
      const [points, setPoints] = useState(createDefaultDeck());
      const [selectedPoint, setSelectedPoint] = useState(null);
      const [deckColor, setDeckColor] = useState('Driftwood');
      const [deckTexture, setDeckTexture] = useState('Smooth');
      const [hasRailings, setHasRailings] = useState(false);
      const [joistSpacing, setJoistSpacing] = useState(0.3048);
      const [beamSpacing, setBeamSpacing] = useState(2.4384);
      const [postSpacing, setPostSpacing] = useState(2.4384);
      const [widthFt, setWidthFt] = useState('12');
      const [lengthFt, setLengthFt] = useState('12');
      const [stairSteps, setStairSteps] = useState(3);
      const [isSidebarOpen, setIsSidebarOpen] = useState(true);
      const [error, setError] = useState(null);
      const [showHelp, setShowHelp] = useState(false);
      const canvas2DRef = useRef(null);
      const canvas3DRef = useRef(null);
      const sceneRef = useRef(null);
      const deckMeshRef = useRef(null);
      const joistMeshesRef = useRef([]);
      const beamMeshesRef = useRef([]);
      const postMeshesRef = useRef([]);
      const railingMeshesRef = useRef([]);
      const stairMeshesRef = useRef([]);
      const cameraRef = useRef(null);
      const shadowGeneratorRef = useRef(null);

      // Debounce utility
      const debounce = (func, wait) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func(...args), wait);
        };
      };

      const handleWidthChange = debounce((value) => setWidthFt(value), 300);
      const handleLengthChange = debounce((value) => setLengthFt(value), 300);

      // 2D Canvas Setup
      useEffect(() => {
        try {
          console.log('Initializing 2D canvas');
          const canvas = canvas2DRef.current;
          if (!canvas) throw new Error('2D canvas not found');
          canvas.width = canvas.offsetWidth || 600;
          canvas.height = 400;
          const ctx = canvas.getContext('2d');
          const drawGrid = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += 50) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, canvas.height);
              ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += 50) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(canvas.width, y);
              ctx.stroke();
            }
          };
          const drawDeck = () => {
            drawGrid();
            if (points.length > 0) {
              ctx.fillStyle = 'rgba(139, 69, 19, 0.7)'; // Brownish tint for wood
              ctx.strokeStyle = 'black';
              ctx.lineWidth = 2;
              ctx.beginPath();
              points.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
                ctx.fillRect(p.x - 4, p.y - 4, 8, 8);
              });
              if (points.length > 2) ctx.closePath();
              ctx.fill(); // Fill with wood-like color
              ctx.stroke(); // Outline
              // Add simple wood grain effect
              ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
              for (let x = 0; x < canvas.width; x += 10) {
                ctx.fillRect(x, 0, 5, canvas.height);
              }
            }
          };
          const handleClick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left) / 50) * 50;
            const y = Math.round((e.clientY - rect.top) / 50) * 50;
            setPoints([...points, { x, y }]);
            setWidthFt('');
            setLengthFt('');
          };
          const handleMouseDown = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const clickedPoint = points.findIndex(p => Math.abs(p.x - x) < 10 && Math.abs(p.y - y) < 10);
            if (clickedPoint !== -1) setSelectedPoint(clickedPoint);
          };
          const handleMouseMove = (e) => {
            if (selectedPoint !== null) {
              const rect = canvas.getBoundingClientRect();
              const x = Math.round((e.clientX - rect.left) / 50) * 50;
              const y = Math.round((e.clientY - rect.top) / 50) * 50;
              const newPoints = [...points];
              newPoints[selectedPoint] = { x, y };
              setPoints(newPoints);
              setWidthFt('');
              setLengthFt('');
            }
          };
          const handleMouseUp = () => {
            setSelectedPoint(null);
          };
          canvas.addEventListener('click', handleClick);
          canvas.addEventListener('mousedown', handleMouseDown);
          canvas.addEventListener('mousemove', handleMouseMove);
          canvas.addEventListener('mouseup', handleMouseUp);
          drawDeck();
          return () => {
            canvas.removeEventListener('click', handleClick);
            canvas.removeEventListener('mousedown', handleMouseDown);
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('mouseup', handleMouseUp);
          };
        } catch (err) {
          console.error('2D canvas error:', err);
          setError('2D canvas initialization failed: ' + err.message);
        }
      }, [points]);

      // 3D Scene Setup
      useEffect(() => {
        try {
          console.log('Initializing Babylon.js');
          const canvas = canvas3DRef.current;
          if (!canvas) throw new Error('3D canvas not found');
          canvas.width = canvas.offsetWidth || 600;
          canvas.height = 400;
          if (!window.BABYLON || !BABYLON.Engine.isSupported()) throw new Error('WebGL or Babylon.js not supported');
          const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
          const scene = new BABYLON.Scene(engine);
          sceneRef.current = scene;

          // Lighting and Shadows
          const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.5), scene); // Sun-like angle
          dirLight.position = new BABYLON.Vector3(20, 40, 20);
          dirLight.intensity = 0.6;
          const shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
          shadowGenerator.useBlurExponentialShadowMap = true;
          shadowGenerator.blurScale = 2;
          shadowGeneratorRef.current = shadowGenerator;

          const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
          hemiLight.intensity = 0.4;

          // Ground with texture
          const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
          const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
          groundMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/grass.jpg", scene);
          ground.material = groundMat;
          ground.receiveShadows = true;

          // Add trees (using billboards for simplicity)
          const treeTexture = new BABYLON.Texture("https://example.com/textures/tree.png", scene);
          const treeMaterial = new BABYLON.StandardMaterial("treeMat", scene);
          treeMaterial.diffuseTexture = treeTexture;
          treeMaterial.backFaceCulling = false;
          for (let i = 0; i < 4; i++) {
            const tree = BABYLON.MeshBuilder.CreatePlane("tree" + i, { size: 5 }, scene);
            tree.material = treeMaterial;
            tree.position = new BABYLON.Vector3(-40 + i * 30, 2.5, -40);
            tree.receiveShadows = true;
          }

          // Add fence
          const fence = BABYLON.MeshBuilder.CreateBox("fence", { width: 100, height: 1.5, depth: 0.1 }, scene);
          const fenceMat = new BABYLON.StandardMaterial("fenceMat", scene);
          fenceMat.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4); // Wood-like color
          fence.material = fenceMat;
          fence.position = new BABYLON.Vector3(0, 0.75, -50);
          fence.receiveShadows = true;
          shadowGenerator.addShadowCaster(fence);

          // Camera setup
          const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 3, Math.PI / 4, 30, new BABYLON.Vector3(0, 0, 0), scene);
          camera.attachControl(canvas, true);
          camera.minZ = 0.1;
          cameraRef.current = camera;

          // Post-processing
          const pipeline = new BABYLON.DefaultRenderingPipeline("default", true, scene, [camera]);
          pipeline.samples = 4;
          pipeline.fxaaEnabled = true;
          pipeline.bloomEnabled = true;

          scene.debugLayer.show({ embedMode: false });
          engine.runRenderLoop(() => {
            try {
              scene.render();
            } catch (err) {
              console.error('Render loop error:', err);
            }
          });
          const handleResize = () => {
            try {
              engine.resize();
            } catch (err) {
              console.error('Resize error:', err);
            }
          };
          window.addEventListener('resize', handleResize);
          return () => {
            window.removeEventListener('resize', handleResize);
            engine.dispose();
          };
        } catch (err) {
          console.error('Babylon.js error:', err);
          setError('3D scene initialization failed: ' + err.message);
        }
      }, []);

      // 3D Deck Update
      useEffect(() => {
        try {
          console.log('Updating 3D deck with points:', points);
          const scene = sceneRef.current;
          const shadowGenerator = shadowGeneratorRef.current;
          if (!scene || !shadowGenerator) return;

          // Clean up existing meshes
          if (deckMeshRef.current) deckMeshRef.current.dispose();
          joistMeshesRef.current.forEach(mesh => mesh.dispose());
          beamMeshesRef.current.forEach(mesh => mesh.dispose());
          postMeshesRef.current.forEach(mesh => mesh.dispose());
          railingMeshesRef.current.forEach(mesh => mesh.dispose());
          stairMeshesRef.current.forEach(mesh => mesh.dispose());
          joistMeshesRef.current = [];
          beamMeshesRef.current = [];
          postMeshesRef.current = [];
          railingMeshesRef.current = [];
          stairMeshesRef.current = [];

          if (points.length >= 3) {
            // Deck mesh
            const vertices = points.map(p => new BABYLON.Vector3(p.x / 50, 0.0254, p.y / 50));
            const deck = BABYLON.MeshBuilder.CreatePolygon("deck", { shape: vertices, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
            const deckMat = new BABYLON.StandardMaterial("deckMat", scene);
            deckMat.diffuseTexture = new BABYLON.Texture(
              `https://example.com/textures/${deckColor.toLowerCase()}_${deckTexture.toLowerCase()}.jpg`, scene
            );
            deckMat.specularTexture = new BABYLON.Texture(
              `https://example.com/textures/${deckColor.toLowerCase()}_${deckTexture.toLowerCase()}_spec.jpg`, scene
            );
            deckMat.bumpTexture = new BABYLON.Texture(
              `https://example.com/textures/${deckColor.toLowerCase()}_${deckTexture.toLowerCase()}_bump.jpg`, scene
            );
            deckMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            deck.material = deckMat;
            deck.receiveShadows = true;
            shadowGenerator.addShadowCaster(deck);
            deckMeshRef.current = deck;

            const bounds = {
              minX: Math.min(...points.map(p => p.x / 50)),
              maxX: Math.max(...points.map(p => p.x / 50)),
              minZ: Math.min(...points.map(p => p.y / 50)),
              maxZ: Math.max(...points.map(p => p.y / 50)),
            };
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerZ = (bounds.minZ + bounds.maxZ) / 2;
            cameraRef.current.target = new BABYLON.Vector3(centerX, 0, centerZ);
            cameraRef.current.radius = Math.max(bounds.maxX - bounds.minX, bounds.maxZ - bounds.minZ) * 1.5;

            // Joists with instancing
            const joistWidth = 0.0381;
            const joistHeight = 0.18415;
            if (joistMeshesRef.current.length === 0) {
              const joistTemplate = BABYLON.MeshBuilder.CreateBox("joistTemplate", { width: joistWidth, height: joistHeight, depth: bounds.maxZ - bounds.minZ }, scene);
              const joistMat = new BABYLON.StandardMaterial("joistMat", scene);
              joistMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
              joistTemplate.material = joistMat;
              joistTemplate.isVisible = false;
              shadowGenerator.addShadowCaster(joistTemplate);
              for (let x = bounds.minX + joistSpacing; x < bounds.maxX; x += joistSpacing) {
                const joist = joistTemplate.createInstance(`joist_${x}`);
                joist.position = new BABYLON.Vector3(x, 0.0254 - joistHeight / 2, (bounds.minZ + bounds.maxZ) / 2);
                joist.receiveShadows = true;
                joistMeshesRef.current.push(joist);
              }
            }

            // Beams
            const beamWidth = 0.0889;
            const beamHeight = 0.18415;
            for (let z = bounds.minZ + beamSpacing; z < bounds.maxZ; z += beamSpacing) {
              const beam = BABYLON.MeshBuilder.CreateBox("beam", { width: bounds.maxX - bounds.minX, height: beamHeight, depth: beamWidth }, scene);
              beam.position = new BABYLON.Vector3((bounds.minX + bounds.maxX) / 2, 0.0254 - beamHeight - joistHeight / 2, z);
              const beamMat = new BABYLON.StandardMaterial("beamMat", scene);
              beamMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
              beam.material = beamMat;
              beam.receiveShadows = true;
              shadowGenerator.addShadowCaster(beam);
              beamMeshesRef.current.push(beam);
            }

            // Posts
            const postWidth = 0.0889;
            const postHeight = 2.4384;
            for (let z = bounds.minZ; z <= bounds.maxZ; z += postSpacing) {
              for (let x = bounds.minX; x <= bounds.maxX; x += postSpacing) {
                const post = BABYLON.MeshBuilder.CreateBox("post", { width: postWidth, height: postHeight, depth: postWidth }, scene);
                post.position = new BABYLON.Vector3(x, -postHeight / 2, z);
                const postMat = new BABYLON.StandardMaterial("postMat", scene);
                postMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                post.material = postMat;
                post.receiveShadows = true;
                shadowGenerator.addShadowCaster(post);
                postMeshesRef.current.push(post);
              }
            }

            // Railings
            if (hasRailings) {
              for (let i = 0; i < points.length; i++) {
                const start = points[i];
                const end = points[(i + 1) % points.length];
                const length = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2) / 50;
                const railing = BABYLON.MeshBuilder.CreateBox("railing", { width: length, height: 0.9144, depth: 0.05 }, scene);
                const midX = (start.x + end.x) / 100;
                const midZ = (start.y + end.y) / 100;
                railing.position = new BABYLON.Vector3(midX, 0.9144 / 2, midZ);
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                railing.rotation.y = angle;
                const railingMat = new BABYLON.StandardMaterial("railingMat", scene);
                railingMat.diffuseColor = new BABYLON.Color3(0.29, 0.18, 0.1);
                railing.material = railingMat;
                railing.receiveShadows = true;
                shadowGenerator.addShadowCaster(railing);
                railingMeshesRef.current.push(railing);
              }
            }
          }
        } catch (err) {
          console.error('3D deck update error:', err);
          setError('Failed to update 3D deck: ' + err.message);
        }
      }, [points, deckColor, deckTexture, hasRailings, joistSpacing, beamSpacing, postSpacing]);

      const handleApplyDimensions = () => {
        try {
          const width = parseFractionalFeet(widthFt);
          const length = parseFractionalFeet(lengthFt);
          if (width <= 0 || length <= 0) throw new Error('Width and length must be positive');
          setPoints(createDefaultDeck(width, length));
        } catch (err) {
          console.error('Apply dimensions error:', err);
          setError('Invalid dimensions: ' + err.message);
        }
      };

      const addStairs = (steps) => {
        try {
          const scene = sceneRef.current;
          const shadowGenerator = shadowGeneratorRef.current;
          if (!scene) return;
          stairMeshesRef.current.forEach(mesh => mesh.dispose());
          stairMeshesRef.current = [];
          const stepHeight = 0.15;
          const stepDepth = 0.3;
          const stairWidth = 1.2;
          const bounds = points.length > 0 ? {
            minX: Math.min(...points.map(p => p.x / 50)),
            maxX: Math.max(...points.map(p => p.x / 50)),
            minZ: Math.min(...points.map(p => p.y / 50)),
            maxZ: Math.max(...points.map(p => p.y / 50)),
          } : { minX: 0, maxX: 12, minZ: 0, maxZ: 12 };
          for (let i = 0; i < steps; i++) {
            const step = BABYLON.MeshBuilder.CreateBox(`step_${i}`, { width: stairWidth, height: stepHeight, depth: stepDepth }, scene);
            step.position = new BABYLON.Vector3(bounds.maxX + stairWidth / 2, i * stepHeight + stepHeight / 2, bounds.maxZ + i * stepDepth);
            const stepMat = new BABYLON.StandardMaterial(`stepMat_${i}`, scene);
            stepMat.diffuseTexture = new BABYLON.Texture(
              `https://example.com/textures/${deckColor.toLowerCase()}_${deckTexture.toLowerCase()}.jpg`, scene
            );
            step.material = stepMat;
            step.receiveShadows = true;
            shadowGenerator.addShadowCaster(step);
            stairMeshesRef.current.push(step);
          }
        } catch (err) {
          console.error('Add stairs error:', err);
          setError('Failed to add stairs: ' + err.message);
        }
      };

      const resetView = () => {
        try {
          if (cameraRef.current) {
            const bounds = points.length > 0 ? {
              minX: Math.min(...points.map(p => p.x / 50)),
              maxX: Math.max(...points.map(p => p.x / 50)),
              minZ: Math.min(...points.map(p => p.y / 50)),
              maxZ: Math.max(...points.map(p => p.y / 50)),
            } : { minX: 0, maxX: 12, minZ: 0, maxZ: 12 };
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerZ = (bounds.minZ + bounds.maxZ) / 2;
            cameraRef.current.target = new BABYLON.Vector3(centerX, 0, centerZ);
            cameraRef.current.radius = Math.max(bounds.maxX - bounds.minX, bounds.maxZ - bounds.minZ) * 1.5;
            cameraRef.current.alpha = Math.PI / 3;
            cameraRef.current.beta = Math.PI / 4;
            console.log('3D view reset');
          }
        } catch (err) {
          console.error('Reset view error:', err);
        }
      };

      const bom = calculateBOM(points, joistSpacing, beamSpacing, postSpacing, hasRailings);
      if (error) {
        return (
          <div className="p-4 text-red-500">
            Error: {error}
            <button className="mxt-btn ml-4" onClick={() => setError(null)}>Clear Error</button>
          </div>
        );
      }

      return (
        <div className="flex flex-col h-screen">
          <div className="bg-gray-800 text-white p-4 flex justify-between items-center">
            <div className="flex items-center">
              <button
                className="mxt-btn mr-4"
                onClick={() => setIsSidebarOpen(!isSidebarOpen)}
              >
                {isSidebarOpen ? 'Hide Sidebar' : 'Show Sidebar'}
              </button>
              <img src="https://via.placeholder.com/150x50?text=American+Pro+Logo" alt="American Pro Logo" className="h-10 mr-4" />
              <h1>American Pro PVC Deck Designer</h1>
            </div>
            <p className="text-sm">1" x 5.5" Decking, 25-Year Warranty</p>
          </div>
          <div className="flex flex-1">
            <div className={`w-1/3 p-4 bg-gray-100 overflow-y-auto transition-all ${isSidebarOpen ? '' : 'w-0 p-0 overflow-hidden'}`}>
              <Panel title="Deck Dimensions">
                <div className="tooltip">
                  <label className="block text-sm font-medium">Width (ft):</label>
                  <div className="flex items-center">
                    <input
                      type="text"
                      value={widthFt}
                      onChange={(e) => handleWidthChange(e.target.value)}
                      className="mxt-form-control w-2/3"
                      placeholder="e.g., 12 1/2"
                    />
                    <button className="mxt-btn ml-2" onClick={() => setShowHelp(true)}>?</button>
                  </div>
                  <span className="tooltiptext">Enter width in feet (e.g., 12 1/2 for 12.5 ft).</span>
                </div>
                <div className="tooltip mt-4">
                  <label className="block text-sm font-medium">Length (ft):</label>
                  <input
                    type="text"
                    value={lengthFt}
                    onChange={(e) => handleLengthChange(e.target.value)}
                    className="mxt-form-control w-2/3"
                    placeholder="e.g., 16 3/4"
                  />
                  <span className="tooltiptext">Enter length in feet (e.g., 16 3/4 for 16.75 ft).</span>
                </div>
                <button className="mxt-btn mt-4 w-full" onClick={handleApplyDimensions}>Apply Dimensions</button>
                <Popover isOpen={showHelp} onClose={() => setShowHelp(false)} x={100} y={100}>
                  <p>Enter dimensions in feet with optional fractions (e.g., 12 1/2 for 12.5 ft). Click Apply to update the deck.</p>
                </Popover>
              </Panel>
              <Panel title="Deck Templates">
                <div className="flex flex-col gap-2">
                  <button
                    className="mxt-btn"
                    onClick={() => setPoints(createDefaultDeck(12, 12))}
                  >
                    Rectangular Deck (12x12 ft)
                  </button>
                  <button
                    className="mxt-btn"
                    onClick={() => {
                      const scale = 50 / 3.28084;
                      setPoints([
                        { x: 0, y: 0 },
                        { x: 12 * 3.28084 * scale, y: 0 },
                        { x: 12 * 3.28084 * scale, y: 12 * 3.28084 * scale },
                        { x: 8 * 3.28084 * scale, y: 12 * 3.28084 * scale },
                        { x: 8 * 3.28084 * scale, y: 16 * 3.28084 * scale },
                        { x: 0, y: 16 * 3.28084 * scale },
                      ]);
                    }}
                  >
                    L-Shaped Deck
                  </button>
                </div>
              </Panel>
              <Panel title="Add Stairs">
                <div className="tooltip">
                  <label className="block text-sm font-medium">Number of Steps:</label>
                  <input
                    type="number"
                    value={stairSteps}
                    onChange={(e) => setStairSteps(Number(e.target.value))}
                    className="mxt-form-control"
                    min="1"
                    max="10"
                  />
                  <span className="tooltiptext">Set the number of steps for the staircase.</span>
                </div>
                <button
                  className="mxt-btn mt-4 w-full"
                  onClick={() => addStairs(stairSteps)}
                >
                  Add Stairs
                </button>
              </Panel>
              <Panel title="Design Controls">
                <div className="tooltip">
                  <label className="block text-sm font-medium">Deck Color:</label>
                  <select
                    value={deckColor}
                    onChange={(e) => setDeckColor(e.target.value)}
                    className="mxt-form-control"
                  >
                    <option value="Driftwood">Driftwood</option>
                    <option value="Khaki">Khaki</option>
                    <option value="Hazelnut">Hazelnut</option>
                    <option value="Ebony">Ebony</option>
                    <option value="Teak">Teak</option>
                  </select>
                  <span className="tooltiptext">Choose from American Pro's premium PVC decking colors.</span>
                </div>
                <div className="tooltip mt-4">
                  <label className="block text-sm font-medium">Texture:</label>
                  <select
                    value={deckTexture}
                    onChange={(e) => setDeckTexture(e.target.value)}
                    className="mxt-form-control"
                  >
                    <option value="Smooth">Smooth</option>
                    <option value="Grooved">Grooved</option>
                  </select>
                  <span className="tooltiptext">Select decking texture for appearance and traction.</span>
                </div>
                <div className="tooltip mt-4">
                  <label className="block text-sm font-medium">Joist Spacing (ft):</label>
                  <div className="flex items-center">
                    <input
                      type="number"
                      value={(joistSpacing * 3.28084).toFixed(2)}
                      onChange={(e) => setJoistSpacing(Number(e.target.value) / 3.28084)}
                      className="mxt-form-control w-2/3"
                      min="0.5"
                      step="0.0625"
                    />
                    <select
                      className="mxt-fraction-select"
                      onChange={(e) => setJoistSpacing((parseFloat(e.target.value) + Math.floor(joistSpacing * 3.28084)) / 3.28084)}
                    >
                      <option value="0">0</option>
                      <option value="0.0625">1/16</option>
                      <option value="0.125">1/8</option>
                      <option value="0.1875">3/16</option>
                      <option value="0.25">1/4</option>
                      <option value="0.3125">5/16</option>
                      <option value="0.375">3/8</option>
                      <option value="0.4375">7/16</option>
                      <option value="0.5">1/2</option>
                      <option value="0.5625">9/16</option>
                      <option value="0.625">5/8</option>
                      <option value="0.6875">11/16</option>
                      <option value="0.75">3/4</option>
                      <option value="0.8125">13/16</option>
                      <option value="0.875">7/8</option>
                      <option value="0.9375">15/16</option>
                    </select>
                  </div>
                  <span className="tooltiptext">Set spacing for 2x8 joists (recommended: 1 ft).</span>
                </div>
                <div className="tooltip mt-4">
                  <label className="block text-sm font-medium">Beam Spacing (ft):</label>
                  <input
                    type="number"
                    value={(beamSpacing * 3.28084).toFixed(2)}
                    onChange={(e) => setBeamSpacing(Number(e.target.value) / 3.28084)}
                    className="mxt-form-control"
                    min="4"
                    step="1"
                  />
                  <span className="tooltiptext">Set spacing for 4x8 beams (recommended: 8 ft).</span>
                </div>
                <div className="tooltip mt-4">
                  <label className="block text-sm font-medium">Post Spacing (ft):</label>
                  <input
                    type="number"
                    value={(postSpacing * 3.28084).toFixed(2)}
                    onChange={(e) => setPostSpacing(Number(e.target.value) / 3.28084)}
                    className="mxt-form-control"
                    min="4"
                    step="1"
                  />
                  <span className="tooltiptext">Set spacing for 4x4 posts (recommended: 8 ft).</span>
                </div>
                <div className="tooltip mt-4">
                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      checked={hasRailings}
                      onChange={(e) => setHasRailings(e.target.checked)}
                      className="mr-2"
                    />
                    Add Railings
                  </label>
                  <span className="tooltiptext">Add standard railings to deck edges.</span>
                </div>
                <div className="tooltip mt-4">
                  <button
                    onClick={() => setPoints(createDefaultDeck())}
                    className="mxt-btn w-full"
                  >
                    Reset Deck
                  </button>
                  <span className="tooltiptext">Reset to default 12 ft x 12 ft deck.</span>
                </div>
              </Panel>
              <Panel title="3D View Controls">
                <div className="tooltip">
                  <button onClick={resetView} className="mxt-btn w-full">
                    Reset 3D View
                  </button>
                  <span className="tooltiptext">Re-center and zoom the 3D view.</span>
                </div>
              </Panel>
              <Panel title="Export Options">
                <div className="tooltip">
                  <input
                    type="file"
                    accept=".json"
                    onChange={(e) => {
                      const file = e.target.files[0];
                      if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                          try {
                            const project = JSON.parse(event.target.result);
                            setPoints(project.points);
                            setDeckColor(project.deckColor);
                            setDeckTexture(project.deckTexture || 'Smooth');
                            setJoistSpacing(project.joistSpacing);
                            setBeamSpacing(project.beamSpacing);
                            setPostSpacing(project.postSpacing);
                            setHasRailings(project.hasRailings);
                            setWidthFt(project.widthFt);
                            setLengthFt(project.lengthFt);
                            setStairSteps(project.stairSteps || 3);
                          } catch (err) {
                            setError('Failed to import project: ' + err.message);
                          }
                        };
                        reader.readAsText(file);
                      }
                    }}
                    className="mxt-form-control mb-2"
                  />
                  <span className="tooltiptext">Import a previously saved project (JSON).</span>
                </div>
                <div className="tooltip">
                  <button
                    onClick={() => exportBlueprint(canvas2DRef.current, points)}
                    className="mxt-btn w-full mb-2"
                  >
                    Export 2D Blueprint (PNG)
                  </button>
                  <span className="tooltiptext">Download a dimensioned 2D blueprint as PNG.</span>
                </div>
                <div className="tooltip">
                  <button
                    onClick={() => exportSvg(points, canvas2DRef.current.width, canvas2DRef.current.height)}
                    className="mxt-btn w-full mb-2"
                  >
                    Export 2D Blueprint (SVG)
                  </button>
                  <span className="tooltiptext">Download a vector blueprint as SVG.</span>
                </div>
                <div className="tooltip">
                  <button
                    onClick={() => BABYLON.Tools.CreateScreenshot(sceneRef.current.getEngine(), sceneRef.current.activeCamera, { width: 800, height: 600 }, (data) => {
                      const link = document.createElement('a');
                      link.download = 'deck_3d_screenshot.png';
                      link.href = data;
                      link.click();
                    })}
                    className="mxt-btn w-full mb-2"
                  >
                    Export 3D Screenshot
                  </button>
                  <span className="tooltiptext">Download a 3D view screenshot as PNG.</span>
                </div>
                <div className="tooltip">
                  <button
                    onClick={() => exportBOM(bom, deckColor, deckTexture)}
                    className="mxt-btn w-full mb-2"
                  >
                    Export BOM (CSV)
                  </button>
                  <span className="tooltiptext">Download a detailed bill of materials as CSV.</span>
                </div>
                <div className="tooltip">
                  <button
                    onClick={() => exportJSON(points, deckColor, deckTexture, joistSpacing, beamSpacing, postSpacing, hasRailings, widthFt, lengthFt, stairSteps)}
                    className="mxt-btn w-full"
                  >
                    Export Project (JSON)
                  </button>
                  <span className="tooltiptext">Download the project data as JSON.</span>
                </div>
              </Panel>
              <Panel title="Bill of Materials">
                <p>Deck Area: {calculateDeckArea(points).toFixed(2)} sq ft</p>
                <p>Estimated Cost: ${(calculateDeckArea(points) * 50 + bom.totalFasteners * 0.5 + bom.railingLength * 100).toFixed(2)}</p>
                {bom.boardsNeeded.map((b, i) => (
                  <p key={i}>Deck Boards: {b.count} x {(b.length * 3.28084).toFixed(0)} ft ({deckColor}, {deckTexture})</p>
                ))}
                <p>Joists: {bom.joistCount} x {bom.joistLength.toFixed(1)} m (2x8)</p>
                <p>Beams: {bom.beamCount} x {bom.beamLength.toFixed(1)} m (4x8)</p>
                <p>Posts: {bom.postCount} x 2.4384 m (4x4)</p>
                {bom.railingLength > 0 && <p>Railing: {bom.railingLength.toFixed(1)} m</p>}
                <p>Fasteners: {bom.totalFasteners} (Hidden)</p>
              </Panel>
            </div>
            <div className="w-2/3 flex flex-col">
              <div className="h-1/2">
                <h2 className="text-lg p-2 bg-gray-300">2D Blueprint (Click to add points, drag to adjust)</h2>
                <canvas ref={canvas2DRef} className="w-full h-[calc(100%-40px)] border" style={{ minHeight: '400px' }} />
              </div>
              <div className="h-1/2">
                <h2 className="text-lg p-2 bg-gray-300">3D View (Drag to rotate)</h2>
                <canvas ref={canvas3DRef} className="w-full h-[calc(100%-40px)] border" style={{ minHeight: '400px' }} />
              </div>
            </div>
          </div>
        </div>
      );
    }

    try {
      console.log('Attempting to render React app');
      const rootElement = document.getElementById('root');
      if (!rootElement) throw new Error('Root element not found');
      const root = createRoot(rootElement);
      root.render(<DeckDesigner />);
      console.log('React app rendered successfully');
    } catch (err) {
      console.error('React render error:', err);
      document.body.innerHTML = '<div class="p-4 text-red-500">Failed to render app: ' + err.message + '. Please check console for details.</div>';
    }
  </script>
</body>
</html>
