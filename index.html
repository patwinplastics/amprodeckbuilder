<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Outdoor Deck Designer</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/Babel.min.js"></script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // DeckDesigner Component
    function DeckDesigner() {
      const [points, setPoints] = useState([]); // 2D points for deck shape
      const [deckMaterial, setDeckMaterial] = useState('wood'); // Deck material
      const [hasRailings, setHasRailings] = useState(false); // Railing toggle
      const [joistSpacing, setJoistSpacing] = useState(0.3048); // Joist spacing in meters
      const canvas2DRef = useRef(null); // 2D canvas for drawing
      const canvas3DRef = useRef(null); // 3D canvas for Babylon.js
      const sceneRef = useRef(null); // Babylon.js scene
      const deckMeshRef = useRef(null); // Deck mesh
      const joistMeshesRef = useRef([]); // Joist meshes
      const railingMeshesRef = useRef([]); // Railing meshes

      // Initialize 2D canvas
      useEffect(() => {
        const canvas = canvas2DRef.current;
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        // Draw grid
        const drawGrid = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = '#ccc';
          ctx.lineWidth = 1;
          for (let x = 0; x <= canvas.width; x += 50) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
          }
          for (let y = 0; y <= canvas.height; y += 50) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          }
        };

        // Draw points and lines
        const drawDeck = () => {
          drawGrid();
          if (points.length > 0) {
            ctx.fillStyle = 'blue';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            points.forEach((p, i) => {
              if (i === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
              ctx.fillRect(p.x - 5, p.y - 5, 10, 10);
            });
            if (points.length > 2) ctx.closePath();
            ctx.stroke();
          }
        };

        // Handle click to add points
        const handleClick = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = Math.round((e.clientX - rect.left) / 50) * 50; // Snap to grid
          const y = Math.round((e.clientY - rect.top) / 50) * 50;
          setPoints([...points, { x, y }]);
        };

        canvas.addEventListener('click', handleClick);
        drawDeck();

        return () => canvas.removeEventListener('click', handleClick);
      }, [points]);

      // Initialize Babylon.js scene
      useEffect(() => {
        const canvas = canvas3DRef.current;
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        sceneRef.current = scene;

        // Camera
        const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 4, Math.PI / 4, 20, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true);

        // Lighting
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.7;

        // Ground
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseColor = new BABYLON.Color3(0.13, 0.55, 0.13);

        // Render loop
        engine.runRenderLoop(() => scene.render());

        // Resize handler
        const handleResize = () => {
          engine.resize();
        };
        window.addEventListener('resize', handleResize);

        return () => {
          window.removeEventListener('resize', handleResize);
          engine.dispose();
        };
      }, []);

      // Update 3D deck based on points, material, railings, and joists
      useEffect(() => {
        const scene = sceneRef.current;
        if (!scene || points.length < 3) return;

        // Clear previous meshes
        if (deckMeshRef.current) deckMeshRef.current.dispose();
        joistMeshesRef.current.forEach(mesh => mesh.dispose());
        railingMeshesRef.current.forEach(mesh => mesh.dispose());
        joistMeshesRef.current = [];
        railingMeshesRef.current = [];

        // Create deck surface
        const vertices = points.map(p => new BABYLON.Vector3(p.x / 50, 0.1, p.y / 50)); // Scale to meters
        const deck = BABYLON.MeshBuilder.CreatePolygon("deck", { shape: vertices, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
        const deckMat = new BABYLON.StandardMaterial("deckMat", scene);
        deckMat.diffuseColor = deckMaterial === 'wood' ? new BABYLON.Color3(0.54, 0.27, 0.07) : new BABYLON.Color3(0.5, 0.5, 0.5);
        deck.material = deckMat;
        deckMeshRef.current = deck;

        // Calculate bounding box for joists
        const bounds = {
          minX: Math.min(...points.map(p => p.x / 50)),
          maxX: Math.max(...points.map(p => p.x / 50)),
          minZ: Math.min(...points.map(p => p.z / 50)),
          maxZ: Math.max(...points.map(p => p.z / 50)),
        };

        // Add joists
        const joistWidth = 0.0381; // 1.5 inches
        const joistHeight = 0.1397; // 5.5 inches
        for (let x = bounds.minX + joistSpacing; x < bounds.maxX; x += joistSpacing) {
          const joist = BABYLON.MeshBuilder.CreateBox("joist", { width: joistWidth, height: joistHeight, depth: bounds.maxZ - bounds.minZ }, scene);
          joist.position = new BABYLON.Vector3(x, 0.05 - joistHeight / 2, (bounds.minZ + bounds.maxZ) / 2);
          joist.material = deckMat;
          joistMeshesRef.current.push(joist);
        }

        // Add railings
        if (hasRailings) {
          for (let i = 0; i < points.length; i++) {
            const start = points[i];
            const end = points[(i + 1) % points.length];
            const length = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2) / 50;
            const railing = BABYLON.MeshBuilder.CreateBox("railing", { width: length, height: 0.9144, depth: 0.05 }, scene); // 3 ft high
            const midX = (start.x + end.x) / 100;
            const midZ = (start.y + end.y) / 100;
            railing.position = new BABYLON.Vector3(midX, 0.9144 / 2, midZ);
            const angle = Math.atan2(end.y - start.y, end.x - start.x);
            railing.rotation.y = angle;
            railing.material = new BABYLON.StandardMaterial("railingMat", scene);
            railing.material.diffuseColor = new BABYLON.Color3(0.29, 0.18, 0.10);
            railingMeshesRef.current.push(railing);
          }
        }
      }, [points, deckMaterial, hasRailings, joistSpacing]);

      // Calculate BOM
      const deckArea = points.length > 2 ? Math.abs(points.reduce((sum, p, i) => {
        const next = points[(i + 1) % points.length];
        return sum + (p.x * next.y - next.x * p.y);
      }, 0) / 2 / 50 / 50) : 0; // Area in square meters
      const boardsNeeded = Math.ceil(deckArea / 0.1858); // Assume 2 sq ft per board (converted to mÂ²)
      const joistCount = joistMeshesRef.current.length;
      const joistLength = points.length > 2 ? (Math.max(...points.map(p => p.y)) - Math.min(...points.map(p => p.y))) / 50 : 0;
      const railingLength = hasRailings ? points.reduce((sum, p, i) => {
        const next = points[(i + 1) % points.length];
        return sum + Math.sqrt((next.x - p.x) ** 2 + (next.y - p.y) ** 2) / 50;
      }, 0) : 0;

      // Export 2D blueprint
      const exportBlueprint = () => {
        const canvas = canvas2DRef.current;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.beginPath();
        points.forEach((p, i) => {
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.closePath();
        ctx.stroke();
        // Add dimensions
        points.forEach((p, i) => {
          const next = points[(i + 1) % points.length];
          const length = Math.sqrt((next.x - p.x) ** 2 + (next.y - p.y) ** 2) / 50;
          ctx.fillStyle = 'black';
          ctx.font = '12px bold Arial';
          ctx.fillText(`${length.toFixed(1)} m`, (p.x + next.x) / 2, (p.y + next.y) / 2);
        });
        const link = document.createElement('a');
        link.download = 'deck_blueprint.png';
        link.href = canvas.toDataURL();
        link.click();
      };

      return (
        <div className="flex h-screen">
          {/* Sidebar */}
          <div className="w-1/3 p-4 bg-gray-100 overflow-y-auto">
            <h1 className="text-2xl font-bold mb-4">Deck Designer</h1>
            <div className="mb-4">
              <label className="block text-sm font-medium">Deck Material:</label>
              <select
                value={deckMaterial}
                onChange={(e) => setDeckMaterial(e.target.value)}
                className="w-full p-2 border rounded"
              >
                <option value="wood">Wood</option>
                <option value="composite">Composite</option>
              </select>
            </div>
            <div className="mb-4">
              <label className="block text-sm font-medium">Joist Spacing (m):</label>
              <input
                type="number"
                value={joistSpacing}
                onChange={(e) => setJoistSpacing(Number(e.target.value))}
                className="w-full p-2 border rounded"
                min="0.1"
                step="0.1"
              />
            </div>
            <div className="mb-4">
              <label className="flex items-center">
                <input
                  type="checkbox"
                  checked={hasRailings}
                  onChange={(e) => setHasRailings(e.target.checked)}
                  className="mr-2"
                />
                Add Railings
              </label>
            </div>
            <button
              onClick={() => setPoints([])}
              className="w-full p-2 bg-red-500 text-white rounded mb-4"
            >
              Clear Deck
            </button>
            <button
              onClick={exportBlueprint}
              className="w-full p-2 bg-blue-500 text-white rounded mb-4"
            >
              Export Blueprint
            </button>
            <div className="mt-6">
              <h2 className="text-lg font-semibold">Bill of Materials</h2>
              <p>Deck Boards: {boardsNeeded} (0.1858 mÂ² each)</p>
              <p>Joists: {joistCount} ({joistLength.toFixed(1)} m each)</p>
              {hasRailings && <p>Railing: {railingLength.toFixed(1)} m</p>}
            </div>
          </div>
          {/* Main Area */}
          <div className="w-2/3 flex flex-col">
            <div className="h-1/2">
              <h2 className="text-lg font-semibold p-2">2D Blueprint</h2>
              <canvas ref={canvas2DRef} className="w-full h-[calc(100%-40px)] border" />
            </div>
            <div className="h-1/2">
              <h2 className="text-lg font-semibold p-2">3D View</h2>
              <canvas ref={canvas3DRef} className="w-full h-[calc(100%-40px)]" />
            </div>
          </div>
        </div>
      );
    }

    // Render the app
    ReactDOM.render(<DeckDesigner />, document.getElementById('root'));
  </script>
</body>
</html>
